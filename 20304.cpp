#include <iostream>
#include <queue>
#include <algorithm>

using namespace std;

int main() {
	// 코드 작성
	ios::sync_with_stdio(0);
	cin.tie(0);


	return 0;
}



/*
최대값과 비교하면서 비트 하나씩 채워나가며 안전도 확인
근데 매번 10만 개(m)를 다 비교할 순 없잖아

m개의 입력의 비트 개수를 다 더해서 비교해??
ㄴ이게 의미가 있는지는 이따 검토해보고
m개의 입력의 최대값에서의 안전도를 다 확인해??
ㄴ이거 가능해 보이는데 뭔가
ㄴ 10만 개를 다 하는 게 아니라 visit이 어느 정도는 해결 가능하려나

비밀번호가 뭐가 1이냐 0이냐

110 xxx일 때만 1
000 001 010 100 101 110

0(0)
0 1(0)
0 10(0) 1 11(1)
0 100(1) 10 110(0) 1 101(1) 11

전체에 대해 확인하는 것은


매번 새로 추가된 비트에 대해서만 확인해도 될까?
이걸 확인하려면 어떻게 해야할까?

어차피 입력에 대해서 비트를 쌓아가며 비교하는 거니까
쌓기 전 결과를 그대로 활용 가능 하다
비트를 추가하고 xor했을 때 XOR 값이 커지면 다른 비트가 추가됐다(이걸로 확인 가능)

*/
/*
확실한 것
일단 안전도가 20을 넘길 순 없음
*/

