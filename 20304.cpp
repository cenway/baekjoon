#include <iostream>
using namespace std;

int main() {
	// 코드 작성
	return 0;
}



/*
0101 5
1010 10
1111 15
n = a^b;
while(n != 0) <- 이거 최적화 안 되나 
if(n%2){ 
	safe_dist++
}
n >> 1

로 안전 거리 측정

제일 간단한 건
최댓값 이하의 숫자에 대해 시도한 모든 비밀번호와의 거리를 중 최소값(안전도)
중에 최대값을 구하기
아이디어
어떻게 하면 여러 값들에 대해 가장 큰 안전 거리를 구할 수 있을까

0을 고를 때/1을 고를 때
비트로 bfs/dfs를 하고 

*/